# demolib
demo library

Основная идея в разделении понятий Фигура (которая может быть нарисована каким-то пером, раскрашена цветом и т.п.)
и Геометрия (которая по сути определяет размещение точек, линий и кривых в координатной плоскости).

Поэтому я решил, что контракт Геометрии вполне может обладать такими признаками как площадь, периметр... 
В то время Фигура - может обладать любой геометрией для возможности рисования ее определеннной кистью и заливкой. 
Само рисование - отдельная и наверное большая тема, поскольку механизму который рисовал бы любую геометрию. В этом случае 
каждая конкретная геометрия (например построенная на точках и на кривых в отдельности) должна была бы уметь передавать 
директивы рисования в контекст рисования так, как это характерно именно для нее.

Что касается вопросов площади треугольника по трем сторонам и круга по радиусу - 
это лишь вопрос разности создания конкретной геометрии (например, треугольник либо по 3м точкам, либо по 3м сторонам, 
либо другими способами). А собственно площадь берется у геометрии в целом вне зависимости от того как она построена (IGeometry.Square()).

Что касается определения на прямоугольность треугольника - этот метод характерин чисто для треугольника (который представлен как наследник 
полигона просто с 3мя точками) поэтому и расположен непосредственно у Треугольной геометрии.

Определил вспомогательные структуры Point, Vector чотбы библиотека и ее алгоритмы были независимы от пространства имен System.Drawing

Юнит тесты хоть и есть но не все покрывают, основные моменты я вроде покрыл.

Что касается вопроса про SQL со статьями и тэгами - мне кажется слишком легкий вопрос, даже не "лидеры в зарплатах по департаментам" :)
В общем, чтобы отобразились в т.ч. статьи без соответствующих тэгов нужен left outer join вместо inner
а многие-ко-многим обычно определяется добавчной таблицей свзки primary ключей обеих таблиц (Article, Tag):

select
  a.Header as [Article]
  t.Value as [Tag]  -- to beautify we could do IsNull(t.Value, '') which would output a blank instead of NULL on missing tags.
  from Article as a
    left join ArticleTagLink as atl on atl.ArticleID = a.ArticleID 
    left join Tag as t on t.TagID = atl.TagID
  Order by a.ArticleID, t.Value; -- just sorting for the sake of visibility
